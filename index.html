<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Teams Channel Creator</title>
  <link rel="icon" href="color.png">
  <style>
    *, *::before, *::after {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: "Segoe UI", -apple-system, BlinkMacSystemFont, sans-serif;
      background: linear-gradient(140deg, #f5f7fb 0%, #e4e7f1 45%, #dbe0ef 100%);
      color: #1f2937;
    }
    main {
      width: min(420px, 90vw);
      padding: 2.25rem;
      border-radius: 20px;
      background: rgba(255, 255, 255, 0.85);
      box-shadow: 0 30px 50px rgba(15, 39, 89, 0.15);
      backdrop-filter: blur(14px);
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }
    header h1 {
      margin: 0;
      font-size: clamp(1.4rem, 4vw, 1.8rem);
      font-weight: 600;
      color: #111827;
    }
    header p {
      margin: 0.35rem 0 0;
      color: #4b5563;
      font-size: 0.95rem;
      line-height: 1.45;
    }
    form {
      display: flex;
      flex-direction: column;
      gap: 0.85rem;
    }
    label {
      font-weight: 600;
      font-size: 0.9rem;
      color: #374151;
    }
    input[type="text"] {
      width: 100%;
      border: 1px solid #cbd5f5;
      border-radius: 10px;
      padding: 0.8rem 0.95rem;
      font-size: 1rem;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
      background: #f9faff;
    }
    input[type="text"]:focus {
      outline: none;
      border-color: #5865f2;
      box-shadow: 0 0 0 3px rgba(88, 101, 242, 0.2);
      background: #ffffff;
    }
    button {
      border: none;
      border-radius: 999px;
      padding: 0.85rem 1.5rem;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      background: linear-gradient(135deg, #4b6ef5, #6d83ff);
      color: #ffffff;
      box-shadow: 0 12px 22px rgba(75, 110, 245, 0.25);
      transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease;
    }
    button:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 16px 28px rgba(75, 110, 245, 0.35);
    }
    button:disabled {
      opacity: 0.55;
      cursor: not-allowed;
      box-shadow: none;
    }
    #status {
      font-size: 0.92rem;
      line-height: 1.4;
      color: #374151;
      min-height: 2rem;
      white-space: pre-line;
    }
    #status.error {
      color: #dc2626;
    }
    #status.success {
      color: #065f46;
    }
  </style>
  <script src="https://res.cdn.office.net/teams-js/2.17.0/js/MicrosoftTeams.min.js" crossorigin="anonymous"></script>
</head>
<body>
  <main>
    <header>
      <h1>Create a New Channel</h1>
      <p>Enter a name and generate a fresh channel in this team without leaving the tab V1.12</p>
    </header>
    <form id="channel-form" autocomplete="off">
      <div>
        <label for="channel-name">Channel name</label>
        <input
          type="text"
          id="channel-name"
          name="channel-name"
          maxlength="50"
          placeholder="e.g. Launch Planning"
          required
        >
      </div>
      <button type="submit" id="generate-button" disabled>Generate</button>
    </form>
    <div id="status" role="status" aria-live="polite" aria-atomic="true"></div>
  </main>
  <script>
    (function channelCreator() {
      let teams = window.microsoftTeams || null;
      const GRAPH_RESOURCE = 'https://graph.microsoft.com';
      const authRedirectUri = new URL('auth.html?teams=1', window.location.href).toString();
      const TAB_APP_REFERENCE_IDS = [
        '34297257-95fb-4214-96e3-729ef51c516c',
        '6263199d-46f9-401c-91b1-bde1ed7a84df'
      ].filter(Boolean);
      const TAB_DISPLAY_NAME = 'Programme';
      const TAB_CONFIG_BASE_URL = 'https://kebbre.github.io/BBProgramme/';
      const TAB_CONFIGURATION_TEMPLATE = ({ channel, teamId: currentTeamId }) => ({
        entityId: channel?.id || '',
        contentUrl: `${TAB_CONFIG_BASE_URL}?team=${encodeURIComponent(currentTeamId || '')}&channel=${encodeURIComponent(channel?.id || '')}`,
        websiteUrl: TAB_CONFIG_BASE_URL
      });
      const APP_INSTALLATION_MAX_ATTEMPTS = 5;
      const APP_INSTALLATION_DELAY_MS = 1200;
      const TAB_APP_CANDIDATES_NORMALISED = TAB_APP_REFERENCE_IDS
        .map((value) => (typeof value === 'string' ? value.trim() : ''))
        .filter(Boolean)
        .map((value) => value.toLowerCase());
      const GRAPH_ITEM_BASE_SEGMENTS = ['Documents', 'Proformat'];
      const GRAPH_TEMPLATE_PATH_SEGMENTS = GRAPH_ITEM_BASE_SEGMENTS
        .map((segment) => (typeof segment === 'string' ? segment.trim() : ''))
        .filter(Boolean);
      const GRAPH_TEMPLATE_COPY_ENABLED = GRAPH_TEMPLATE_PATH_SEGMENTS.length > 0;
      const GRAPH_CHANNEL_FILES_FOLDER_MAX_ATTEMPTS = 8;
      const GRAPH_CHANNEL_FILES_FOLDER_DELAY_MS = 1500;
      const GRAPH_COPY_STATUS_POLL_INTERVAL_MS = 2000;
      const GRAPH_COPY_STATUS_TIMEOUT_MS = 4 * 60 * 1000;

      const form = document.getElementById('channel-form');
      const input = document.getElementById('channel-name');
      const button = document.getElementById('generate-button');
      const statusEl = document.getElementById('status');

      let teamId;
      let cachedAccessToken = null;
      let cachedAccessTokenExpiry = 0;
      const TOKEN_EXPIRY_BUFFER_MS = 2 * 60 * 1000;
      const DEFAULT_TOKEN_TTL_MS = 55 * 60 * 1000;

      function delay(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      function normaliseId(value) {
        return typeof value === 'string' ? value.toLowerCase() : '';
      }

      function resolveTabDisplayName(channel) {
        try {
          if (typeof TAB_DISPLAY_NAME === 'function') {
            const resolved = TAB_DISPLAY_NAME({ channel, teamId });
            if (resolved) {
              return String(resolved);
            }
          } else if (TAB_DISPLAY_NAME) {
            return String(TAB_DISPLAY_NAME);
          }
        } catch (error) {
          console.debug('Unable to resolve tab display name.', error);
        }
        return channel?.displayName || 'Channel App';
      }

      function resolveTabConfiguration(context) {
        if (!TAB_CONFIGURATION_TEMPLATE) {
          return null;
        }
        try {
          const template = typeof TAB_CONFIGURATION_TEMPLATE === 'function'
            ? TAB_CONFIGURATION_TEMPLATE(context)
            : TAB_CONFIGURATION_TEMPLATE;
          if (!template || typeof template !== 'object') {
            return null;
          }
          return JSON.parse(JSON.stringify(template));
        } catch (error) {
          console.debug('Unable to resolve tab configuration.', error);
          return null;
        }
      }

      function encodeDrivePathSegments(segments) {
        return segments
          .map((segment) => encodeURIComponent(segment))
          .join('/');
      }

      async function fetchTemplateFolder(accessToken) {
        if (!GRAPH_TEMPLATE_COPY_ENABLED || !GRAPH_TEMPLATE_PATH_SEGMENTS.length) {
          return null;
        }
        const displayPath = GRAPH_TEMPLATE_PATH_SEGMENTS.join('/');
        const encodedPath = encodeDrivePathSegments(GRAPH_TEMPLATE_PATH_SEGMENTS);
        const response = await graphRequest(`/me/drive/root:/${encodedPath}`, accessToken);
        if (response.status === 404) {
          throw new Error(`Template folder not found at "/${displayPath}".`);
        }
        if (!response.ok) {
          throw new Error(await readGraphErrorMessage(response, 'Unable to access the template folder.'));
        }
        const payload = await response.json();
        if (!payload?.folder) {
          throw new Error(`Template path "/${displayPath}" is not a folder.`);
        }
        if (!payload?.id) {
          throw new Error('Template folder metadata is missing an identifier.');
        }
        return payload;
      }

      async function ensureChannelFilesFolder(channelId, accessToken) {
        if (!teamId) {
          throw new Error('Team context unavailable for locating channel files folder.');
        }
        for (let attempt = 0; attempt < GRAPH_CHANNEL_FILES_FOLDER_MAX_ATTEMPTS; attempt += 1) {
          const response = await graphRequest(`/teams/${teamId}/channels/${channelId}/filesFolder`, accessToken);
          if (response.status === 200) {
            const payload = await response.json();
            const driveId = payload?.driveId || payload?.parentReference?.driveId;
            if (payload?.id && driveId) {
              return {
                id: payload.id,
                driveId,
                name: payload.name || '',
                raw: payload
              };
            }
          } else if (response.status === 202 || response.status === 404) {
            // Folder not provisioned yet; wait and retry.
          } else {
            throw new Error(await readGraphErrorMessage(response, 'Unable to locate the channel files folder.'));
          }
          if (attempt < GRAPH_CHANNEL_FILES_FOLDER_MAX_ATTEMPTS - 1) {
            await delay(GRAPH_CHANNEL_FILES_FOLDER_DELAY_MS * Math.max(1, attempt + 1));
          }
        }
        throw new Error('Channel files folder not yet available.');
      }

      function normaliseGraphNextLink(nextLink) {
        if (typeof nextLink !== 'string') {
          return null;
        }
        let candidate = nextLink.trim();
        if (!candidate) {
          return null;
        }
        try {
          const absolute = new URL(candidate);
          candidate = `${absolute.pathname}${absolute.search}`;
        } catch (error) {
          // Relative path already.
        }
        if (candidate.startsWith(`${GRAPH_RESOURCE}/v1.0`)) {
          candidate = candidate.slice(`${GRAPH_RESOURCE}/v1.0`.length);
        }
        if (candidate.startsWith('/v1.0')) {
          candidate = candidate.slice('/v1.0'.length);
        }
        if (!candidate.startsWith('/')) {
          candidate = `/${candidate}`;
        }
        return candidate;
      }

      function normaliseCopyMonitorUrl(operationUrl) {
        if (typeof operationUrl !== 'string' || !operationUrl.trim()) {
          return null;
        }
        let candidate = operationUrl.trim();
        try {
          const parsed = new URL(candidate, GRAPH_RESOURCE);
          const lowerHost = parsed.host.toLowerCase();
          if (lowerHost.includes('sharepoint.com')) {
            // SharePoint async endpoints use /_api/v2.x; convert to graph-relative path.
            const pathSegments = parsed.pathname.split('/').filter(Boolean);
            const apiIndex = pathSegments.findIndex((segment) => segment.toLowerCase() === '_api');
            if (apiIndex >= 0) {
              let startIndex = apiIndex + 1;
              const versionPattern = /^v\d+(\.\d+)?$/i;
              while (startIndex < pathSegments.length && versionPattern.test(pathSegments[startIndex])) {
                startIndex += 1;
              }
              const remaining = pathSegments.slice(startIndex);
              if (remaining.length) {
                candidate = `/${remaining.join('/')}${parsed.search}`;
              } else {
                candidate = `${parsed.pathname}${parsed.search}`;
              }
            } else {
              candidate = `${parsed.pathname}${parsed.search}`;
            }
          } else if (parsed.origin.toLowerCase() === GRAPH_RESOURCE.toLowerCase()) {
            candidate = `${parsed.pathname}${parsed.search}`;
          }
        } catch (error) {
          // Treat as relative path.
        }
        if (candidate.startsWith(`${GRAPH_RESOURCE}/v1.0`)) {
          candidate = candidate.slice(`${GRAPH_RESOURCE}/v1.0`.length);
        }
        if (candidate.startsWith('/v1.0')) {
          candidate = candidate.slice('/v1.0'.length);
        }
        if (!candidate.startsWith('/')) {
          candidate = `/${candidate}`;
        }
        return `${GRAPH_RESOURCE}/v1.0${candidate}`;
      }

      async function listTemplateFolderChildren(folderId, accessToken) {
        const items = [];
        let path = `/me/drive/items/${folderId}/children`;
        while (path) {
          const response = await graphRequest(path, accessToken);
          if (!response.ok) {
            throw new Error(await readGraphErrorMessage(response, 'Unable to read template folder contents.'));
          }
          const payload = await response.json();
          if (Array.isArray(payload?.value)) {
            items.push(...payload.value.filter((item) => item?.id && item?.name));
          }
          const nextLink = normaliseGraphNextLink(payload?.['@odata.nextLink']);
          path = nextLink;
        }
        return items;
      }

      async function monitorGraphCopyOperation(operationUrl, accessToken, { initialDelayMs = GRAPH_COPY_STATUS_POLL_INTERVAL_MS } = {}) {
        if (!operationUrl) {
          return;
        }
        const resolvedUrl = normaliseCopyMonitorUrl(operationUrl) || operationUrl;
        const startTime = Date.now();
        let waitMs = Math.max(0, initialDelayMs);
        while ((Date.now() - startTime) < GRAPH_COPY_STATUS_TIMEOUT_MS) {
          if (waitMs > 0) {
            await delay(waitMs);
          }
          const response = await fetch(resolvedUrl, {
            method: 'GET',
            headers: {
              'Authorization': `Bearer ${accessToken}`,
              'Accept': 'application/json'
            }
          });
          if (response.status >= 400) {
            throw new Error(await readGraphErrorMessage(response, 'Copy operation monitoring failed.'));
          }
          if (response.status === 204) {
            return;
          }
          let payload = null;
          try {
            payload = await response.json();
          } catch (error) {
            payload = null;
          }
          const status = typeof payload?.status === 'string' ? payload.status.toLowerCase() : '';
          if (!status) {
            if (response.status === 200 || response.status === 201) {
              return;
            }
          } else if (status === 'completed') {
            return;
          } else if (status === 'failed') {
            throw new Error(payload?.error?.message || 'Template copy operation failed.');
          }
          const retryAfterHeader = response.headers.get('Retry-After');
          const retrySeconds = retryAfterHeader ? Number.parseInt(retryAfterHeader, 10) : NaN;
          waitMs = Number.isFinite(retrySeconds) && retrySeconds > 0
            ? retrySeconds * 1000
            : GRAPH_COPY_STATUS_POLL_INTERVAL_MS;
        }
        throw new Error('Timed out waiting for template content to copy.');
      }

      async function copyDriveItemToDestination(item, destination, accessToken) {
        const driveId = destination?.driveId;
        const folderId = destination?.id;
        if (!item?.id || !driveId || !folderId) {
          throw new Error('Missing information required to copy the template content.');
        }
        const response = await graphRequest(`/me/drive/items/${item.id}/copy`, accessToken, {
          method: 'POST',
          headers: {
            'Prefer': 'respond-async'
          },
          body: {
            name: item.name,
            parentReference: {
              driveId,
              id: folderId
            }
          }
        });
        if (response.status === 409) {
          return { conflict: true };
        }
        if (response.status === 201 || response.status === 200 || response.status === 204) {
          return { success: true };
        }
        if (response.status === 202) {
          const asyncOperationUrl = response.headers.get('Azure-AsyncOperation')
            || response.headers.get('azure-asyncoperation')
            || response.headers.get('Location')
            || response.headers.get('location');
          const retryAfterHeader = response.headers.get('Retry-After');
          const retrySeconds = retryAfterHeader ? Number.parseInt(retryAfterHeader, 10) : NaN;
          const initialDelayMs = Number.isFinite(retrySeconds) && retrySeconds > 0
            ? retrySeconds * 1000
            : GRAPH_COPY_STATUS_POLL_INTERVAL_MS;
          await monitorGraphCopyOperation(asyncOperationUrl, accessToken, { initialDelayMs });
          return { success: true };
        }
        throw new Error(await readGraphErrorMessage(response, `Unable to copy "${item.name}".`));
      }

      async function duplicateTemplateFolderToChannel(channel, accessToken) {
        if (!GRAPH_TEMPLATE_COPY_ENABLED) {
          return { skipped: true };
        }
        if (!channel?.id) {
          return { error: 'Channel identifier unavailable for template content copy.' };
        }
        let templateFolder = null;
        try {
          templateFolder = await fetchTemplateFolder(accessToken);
        } catch (error) {
          return { error: error?.message || 'Unable to resolve the template folder.' };
        }
        if (!templateFolder) {
          return { skipped: true };
        }
        let destinationFolder = null;
        try {
          destinationFolder = await ensureChannelFilesFolder(channel.id, accessToken);
        } catch (error) {
          return { error: error?.message || 'Unable to access the channel files folder.' };
        }
        let children = [];
        try {
          children = await listTemplateFolderChildren(templateFolder.id, accessToken);
        } catch (error) {
          return { error: error?.message || 'Unable to read template folder contents.' };
        }
        if (!Array.isArray(children) || !children.length) {
          return { copied: 0, empty: true };
        }
        let copied = 0;
        let conflicts = 0;
        for (const item of children) {
          if (!item?.id || !item?.name) {
            continue;
          }
          try {
            const outcome = await copyDriveItemToDestination(item, destinationFolder, accessToken);
            if (outcome?.conflict) {
              conflicts += 1;
            } else {
              copied += 1;
            }
          } catch (copyError) {
            return {
              error: copyError?.message || `Unable to copy "${item?.name}".`,
              copied,
              conflicts
            };
          }
        }
        return { copied, conflicts };
      }

      async function readGraphErrorMessage(response, fallbackMessage) {
        if (!response) {
          return fallbackMessage || 'Unknown error';
        }
        try {
          const payload = await response.json();
          const graphError = payload?.error?.message || payload?.message;
          if (graphError) {
            return graphError;
          }
        } catch (parseError) {
          console.debug('Unable to parse Graph error payload.', parseError);
        }
        if (response.status && response.statusText) {
          return `${response.status} ${response.statusText}`.trim();
        }
        return fallbackMessage || 'Unknown error';
      }

      function isCandidateApp(teamsAppDefinition) {
        if (!teamsAppDefinition || !TAB_APP_CANDIDATES_NORMALISED.length) {
          return false;
        }
        const candidateIds = [
          teamsAppDefinition?.id,
          teamsAppDefinition?.externalId,
          teamsAppDefinition?.teamsAppId
        ];
        return candidateIds
          .map((value) => (typeof value === 'string' ? value.toLowerCase() : ''))
          .some((value) => value && TAB_APP_CANDIDATES_NORMALISED.includes(value));
      }

      async function graphRequest(path, accessToken, options = {}) {
        const {
          method = 'GET',
          headers,
          body,
          ...rest
        } = options;
        const requestHeaders = {
          'Authorization': `Bearer ${accessToken}`,
          'Accept': 'application/json',
          ...(headers || {})
        };
        const init = {
          method,
          ...rest,
          headers: requestHeaders
        };
        if (body !== undefined) {
          requestHeaders['Content-Type'] = 'application/json';
          init.body = typeof body === 'string' ? body : JSON.stringify(body);
        }
        return fetch(`${GRAPH_RESOURCE}/v1.0${path}`, init);
      }

      async function listInstalledApps(team, accessToken) {
        const response = await graphRequest(`/teams/${team}/installedApps?$expand=teamsApp($select=id,externalId,displayName)`, accessToken);
        if (!response.ok) {
          throw new Error(await readGraphErrorMessage(response, 'Unable to verify existing app installations.'));
        }
        const payload = await response.json();
        return Array.isArray(payload?.value) ? payload.value : [];
      }

      async function ensureTeamsAppInstalled(team, accessToken) {
        if (!TAB_APP_REFERENCE_IDS.length) {
          return;
        }
        let alreadyInstalled = false;
        try {
          const existing = await listInstalledApps(team, accessToken);
          alreadyInstalled = existing.some((item) => isCandidateApp(item?.teamsApp));
        } catch (checkError) {
          console.debug('Unable to check existing app installations.', checkError);
        }
        if (alreadyInstalled) {
          return;
        }

        let installationError = null;
        let installationErrorId = null;
        for (const candidate of TAB_APP_REFERENCE_IDS) {
          const trimmedCandidate = typeof candidate === 'string' ? candidate.trim() : '';
          if (!trimmedCandidate) {
            continue;
          }
          try {
            const installResponse = await graphRequest(`/teams/${team}/installedApps`, accessToken, {
              method: 'POST',
              body: {
                'teamsApp@odata.bind': `${GRAPH_RESOURCE}/v1.0/appCatalogs/teamsApps/${trimmedCandidate}`
              }
            });
            if (installResponse.status === 201 || installResponse.status === 202) {
              installationError = null;
              installationErrorId = null;
              break;
            }
            if (installResponse.status === 409) {
              installationError = null;
              installationErrorId = null;
              break;
            }
            const reason = await readGraphErrorMessage(installResponse, `Unable to install the Teams app (${trimmedCandidate}) in this team.`);
            installationError = new Error(`${reason} [AppId: ${trimmedCandidate}]`);
            installationErrorId = trimmedCandidate;
          } catch (installAttemptError) {
            installationError = installAttemptError;
            installationErrorId = trimmedCandidate;
          }
        }
        if (installationError) {
          if (installationErrorId && !installationError.message.includes('[AppId:')) {
            installationError.message = `${installationError.message} [AppId: ${installationErrorId}]`;
          }
          throw installationError;
        }

        for (let attempt = 0; attempt < APP_INSTALLATION_MAX_ATTEMPTS; attempt += 1) {
          await delay(APP_INSTALLATION_DELAY_MS * (attempt + 1));
          try {
            const existing = await listInstalledApps(team, accessToken);
            if (existing.some((item) => isCandidateApp(item?.teamsApp))) {
              return;
            }
          } catch (pollError) {
            console.debug('App installation verification attempt failed.', pollError);
          }
        }
        throw new Error('Unable to verify Teams app installation in the team.');
      }

      async function findExistingTab(channelId, accessToken) {
        if (!TAB_APP_CANDIDATES_NORMALISED.length || !teamId) {
          return null;
        }
        const response = await graphRequest(`/teams/${teamId}/channels/${channelId}/tabs?$expand=teamsApp`, accessToken);
        if (!response.ok) {
          throw new Error(await readGraphErrorMessage(response, 'Unable to check existing channel tabs.'));
        }
        const payload = await response.json();
        const tabs = Array.isArray(payload?.value) ? payload.value : [];
        return tabs.find((tab) => {
          const tabAppId = normaliseId(tab?.teamsApp?.id)
            || normaliseId(tab?.teamsAppId)
            || normaliseId(tab?.teamsApp?.externalId);
          return tabAppId && TAB_APP_CANDIDATES_NORMALISED.includes(tabAppId);
        }) || null;
      }

      async function ensureChannelTab(channel, accessToken) {
        if (!TAB_APP_REFERENCE_IDS.length) {
          return { skipped: true };
        }
        if (!teamId) {
          return { error: 'Team context unavailable for app tab creation.' };
        }
        if (!channel?.id) {
          return { error: 'Channel identifier unavailable for app tab creation.' };
        }

        try {
          const existingTab = await findExistingTab(channel.id, accessToken);
          if (existingTab) {
            return { alreadyExists: true };
          }
        } catch (lookupError) {
          console.debug('Unable to check for existing channel tabs.', lookupError);
        }

        try {
          await ensureTeamsAppInstalled(teamId, accessToken);
        } catch (installError) {
          throw new Error(installError?.message || 'Unable to install the Teams app before creating the tab.');
        }

        let lastError = null;
        let lastErrorId = null;
        for (const candidate of TAB_APP_REFERENCE_IDS) {
          const trimmedCandidate = typeof candidate === 'string' ? candidate.trim() : '';
          if (!trimmedCandidate) {
            continue;
          }
          const tabPayload = {
            displayName: resolveTabDisplayName(channel),
            'teamsApp@odata.bind': `${GRAPH_RESOURCE}/v1.0/appCatalogs/teamsApps/${trimmedCandidate}`
          };
          const configuration = resolveTabConfiguration({ channel, teamId });
          if (configuration) {
            tabPayload.configuration = configuration;
          }

          try {
            const response = await graphRequest(`/teams/${teamId}/channels/${channel.id}/tabs`, accessToken, {
              method: 'POST',
              body: tabPayload
            });

            if (response.status === 201) {
              return { created: true, tab: await response.json().catch(() => null) };
            }
            if (response.status === 409) {
              return { alreadyExists: true };
            }
            if (response.status >= 200 && response.status < 300) {
              return { created: true, tab: await response.json().catch(() => null) };
            }
            lastError = await readGraphErrorMessage(response, 'Unable to add the app tab to the channel.');
            lastErrorId = trimmedCandidate;
          } catch (tabError) {
            lastError = tabError?.message || 'Unable to add the app tab to the channel.';
            lastErrorId = trimmedCandidate;
          }
        }

        const detail = lastError || 'Unable to add the app tab to the channel.';
        return {
          error: lastErrorId ? `${detail} [AppId: ${lastErrorId}]` : detail
        };
      }

      async function waitForTeamsSdk(timeoutMs = 6000) {
        const start = Date.now();
        while (Date.now() - start < timeoutMs) {
          teams = window.microsoftTeams || teams;
          if (teams?.app?.initialize || typeof teams?.initialize === 'function') {
            return teams;
          }
          await delay(100);
        }
        throw new Error('Microsoft Teams SDK unavailable. Please confirm this tab is running inside Microsoft Teams.');
      }

      async function runTeamsAuthentication(options) {
        if (!teams?.authentication?.authenticate) {
          throw new Error('Teams authentication APIs unavailable.');
        }
        return new Promise((resolve, reject) => {
          let settled = false;
          const config = {
            ...options,
            successCallback: (value) => {
              if (!settled) {
                settled = true;
                resolve(value);
              }
            },
            failureCallback: (reason) => {
              if (!settled) {
                settled = true;
                const error = reason instanceof Error ? reason : new Error(reason || 'Authentication failed.');
                reject(error);
              }
            }
          };
          try {
            const maybePromise = teams.authentication.authenticate(config);
            if (maybePromise && typeof maybePromise.then === 'function') {
              maybePromise.then((value) => {
                if (!settled) {
                  settled = true;
                  resolve(value);
                }
              }).catch((error) => {
                if (!settled) {
                  settled = true;
                  reject(error);
                }
              });
            }
          } catch (error) {
            if (!settled) {
              settled = true;
              reject(error);
            }
          }
        });
      }

      function setStatus(message, tone) {
        statusEl.textContent = message || '';
        statusEl.classList.remove('error', 'success');
        if (tone) {
          statusEl.classList.add(tone);
        }
      }

      function setFormEnabled(enabled) {
        input.disabled = !enabled;
        button.disabled = !enabled;
      }

      async function bootstrapTeamsContext() {
        await waitForTeamsSdk();
        let context;

        if (teams?.app?.initialize && typeof teams.app.getContext === 'function') {
          await teams.app.initialize();
          context = await teams.app.getContext();
        } else if (typeof teams.initialize === 'function' && typeof teams.getContext === 'function') {
          await new Promise((resolve, reject) => {
            try {
              teams.initialize(() => resolve(), (reason) => reject(new Error(reason || 'Teams initialization failed.')));
            } catch (initError) {
              reject(initError);
            }
          });
          context = await new Promise((resolve, reject) => {
            let settled = false;
            const timeoutId = setTimeout(() => {
              if (!settled) {
                reject(new Error('Timed out retrieving Microsoft Teams context.'));
              }
            }, 4000);
            teams.getContext((ctx) => {
              settled = true;
              clearTimeout(timeoutId);
              resolve(ctx);
            });
          });
        } else {
          throw new Error('Microsoft Teams SDK unavailable. Please make sure the Teams JavaScript SDK is referenced.');
        }

        teamId = context?.team?.groupId || context?.groupId || context?.teamId || null;
        if (!teamId) {
          throw new Error('This experience is only available inside a team channel tab.');
        }
      }

      function applyAuthenticationPayload(payload) {
        if (!payload || !payload.accessToken) {
          return null;
        }
        cachedAccessToken = payload.accessToken;
        let expiresAt = 0;
        if (payload.expiresOn) {
          const parsed = Date.parse(payload.expiresOn);
          if (!Number.isNaN(parsed)) {
            expiresAt = parsed;
          }
        } else if (typeof payload.expiresIn === 'number' && Number.isFinite(payload.expiresIn)) {
          expiresAt = Date.now() + Math.max(0, payload.expiresIn * 1000);
        }
        if (!expiresAt) {
          expiresAt = Date.now() + DEFAULT_TOKEN_TTL_MS;
        }
        cachedAccessTokenExpiry = expiresAt;
        return cachedAccessToken;
      }

      window.addEventListener('message', (event) => {
        if (event.origin !== window.location.origin) {
          return;
        }
        const data = event.data;
        if (!data || typeof data !== 'object' || data.type !== 'bbprogramme-auth-complete') {
          return;
        }
        if (!data.success) {
          console.debug('Authentication message indicated failure.', data.error);
          return;
        }
        applyAuthenticationPayload(data);
      });

      async function interactiveLogin() {
        const result = await runTeamsAuthentication({
          url: authRedirectUri,
          width: 640,
          height: 640
        });
        if (!result) {
          throw new Error('Authentication did not return a result.');
        }
        let payload = null;
        if (typeof result === 'string') {
          try {
            payload = JSON.parse(result);
          } catch (parseError) {
            payload = { accessToken: result };
          }
        } else if (typeof result === 'object') {
          payload = result;
        }
        if (payload?.success === false) {
          throw new Error(payload?.error || 'Authentication failed.');
        }
        if (!payload?.accessToken && typeof result === 'string') {
          payload = { accessToken: result };
        }
        if (!payload?.accessToken) {
          throw new Error('Authentication response did not include an access token.');
        }
        applyAuthenticationPayload(payload);
        return cachedAccessToken;
      }

      async function acquireGraphToken({ forceRefresh = false } = {}) {
        const now = Date.now();
        if (!forceRefresh && cachedAccessToken && (cachedAccessTokenExpiry - TOKEN_EXPIRY_BUFFER_MS) > now) {
          return cachedAccessToken;
        }
        cachedAccessToken = null;
        cachedAccessTokenExpiry = 0;
        const token = await interactiveLogin();
        if (!token) {
          throw new Error('Unable to acquire an access token for Microsoft Graph.');
        }
        return token;
      }

      async function createChannel(displayName) {
        const trimmedName = displayName.trim();
        if (!trimmedName) {
          throw new Error('Please provide a channel name.');
        }
        if (trimmedName.length > 50) {
          throw new Error('Channel names must be 50 characters or fewer.');
        }

        async function sendCreateRequest(token) {
          return fetch(`${GRAPH_RESOURCE}/v1.0/teams/${teamId}/channels`, {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${token}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              displayName: trimmedName
            })
          });
        }

        let accessToken = await acquireGraphToken();
        if (!accessToken) {
          throw new Error('Unable to acquire an access token for Microsoft Graph.');
        }

        let response = await sendCreateRequest(accessToken);

        if (response.status === 401) {
          cachedAccessToken = null;
          cachedAccessTokenExpiry = 0;
          accessToken = await acquireGraphToken({ forceRefresh: true });
          if (!accessToken) {
            throw new Error('Authentication expired. Please sign in again.');
          }
          response = await sendCreateRequest(accessToken);
        }

        if (response.status === 201) {
          const payload = await response.json();
          let filesOutcome = { skipped: !GRAPH_TEMPLATE_COPY_ENABLED };
          try {
            filesOutcome = await duplicateTemplateFolderToChannel(payload, accessToken);
          } catch (filesError) {
            filesOutcome = { error: filesError?.message || 'Unable to apply template content to the Files tab.' };
            console.error('Copying template content failed.', filesError);
          }
          let tabOutcome = { skipped: !TAB_APP_REFERENCE_IDS.length };
          try {
            tabOutcome = await ensureChannelTab(payload, accessToken);
          } catch (tabError) {
            tabOutcome = { error: tabError?.message || 'Unable to add the app tab to the channel.' };
            console.error('Adding default app tab failed.', tabError);
          }
          return { channel: payload, tabOutcome, filesOutcome };
        }

        const errorMessage = await readGraphErrorMessage(response, 'Unable to create the channel.');
        throw new Error(errorMessage);
      }

      async function handleSubmit(event) {
        event.preventDefault();
        setFormEnabled(false);
        setStatus('Creating channel...');
        try {
          const requestedName = input.value;
          const result = await createChannel(requestedName);
          const channelName = result?.channel?.displayName || requestedName.trim();
          const tabOutcome = result?.tabOutcome || {};
          const filesOutcome = result?.filesOutcome || {};

          let message = `Channel "${channelName}" created successfully.`;
          if (filesOutcome.copied > 0) {
            message += ` ${filesOutcome.copied} item(s) copied to Files tab.`;
          }
          if (filesOutcome.conflicts) {
            message += ` ${filesOutcome.conflicts} item(s) already existed in Files.`;
          }
          if (filesOutcome.empty && !filesOutcome.copied && !filesOutcome.conflicts) {
            message += ' Template folder was empty.';
          }
          if (filesOutcome.error) {
            message += `\nHowever, template content could not be copied: ${filesOutcome.error}`;
          }
          if (tabOutcome.created) {
            message += ' App tab added.';
          } else if (tabOutcome.alreadyExists) {
            message += ' App tab already present.';
          } else if (tabOutcome.skipped) {
            // No-op: tab creation intentionally skipped.
          } else if (tabOutcome.error) {
            message += `\nHowever, the app tab could not be added: ${tabOutcome.error}`;
          }

          const tone = (tabOutcome.error || filesOutcome.error) ? 'error' : 'success';
          setStatus(message, tone);
          input.value = '';
        } catch (error) {
          const message = error?.message || 'Unable to create channel.';
          setStatus(message, 'error');
          console.error('Channel creation failed.', error);
        } finally {
          setFormEnabled(true);
        }
      }

      async function initialise() {
        try {
          setStatus('Connecting to Microsoft Teams...');
          await bootstrapTeamsContext();
          setStatus('Ready to create channels.');
          setFormEnabled(true);
        } catch (error) {
          setStatus(error?.message || 'Unable to initialise the experience.', 'error');
          console.error('Initialisation failed.', error);
        }
      }

      form.addEventListener('submit', handleSubmit);
      setFormEnabled(false);
      initialise();
    }());
  </script>
</body>
</html>
