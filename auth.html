<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Microsoft Authentication</title>
  <style>
    body {
      font-family: "Segoe UI", -apple-system, BlinkMacSystemFont, sans-serif;
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #f3f4f6;
      color: #1f2937;
    }
    .message {
      text-align: center;
      max-width: 320px;
      line-height: 1.5;
      font-size: 0.95rem;
    }
  </style>
  <script src="https://alcdn.msauth.net/browser/2.37.0/js/msal-browser.min.js" crossorigin="anonymous"></script>
  <script src="https://res.cdn.office.net/teams-js/2.17.0/js/MicrosoftTeams.min.js" crossorigin="anonymous"></script>
</head>
<body>
  <div class="message">
    <p>Completing Microsoft sign-in...</p>
  </div>
  <script>
    (async function finishAuthentication() {
      const CLIENT_ID = '11110eb6-00e3-4870-a044-670147117b83';
      const TENANT_ID = '6dc7041f-549e-4127-9e89-36f74513bad5';
      const authority = TENANT_ID
        ? `https://login.microsoftonline.com/${TENANT_ID}`
        : 'https://login.microsoftonline.com/common';
      const redirectUri = new URL('auth.html', window.location.href).toString();
      const GRAPH_SCOPES = ['User.Read', 'Files.ReadWrite.All', 'Channel.Create'];
      const REDIRECT_SESSION_KEY = 'bbprogramme:auth-redirect-started';
      const TOKEN_REDIRECT_KEY = 'bbprogramme:auth-token-redirect';
      const teams = window.microsoftTeams;

      function setRedirectFlag(key) {
        try {
          window.sessionStorage.setItem(key, '1');
        } catch (storageError) {
          console.debug('Unable to set redirect flag.', storageError);
        }
      }

      function clearRedirectFlag(key) {
        try {
          window.sessionStorage.removeItem(key);
        } catch (storageError) {
          console.debug('Unable to clear redirect flag.', storageError);
        }
      }

      function hasRedirectFlag(key) {
        try {
          return window.sessionStorage.getItem(key) === '1';
        } catch (storageError) {
          console.debug('Unable to read redirect flag.', storageError);
          return false;
        }
      }

      async function initialiseTeamsSdk() {
        if (!teams) {
          return null;
        }
        if (teams?.app && typeof teams.app.initialize === 'function') {
          try {
            await teams.app.initialize();
          } catch (teamsInitError) {
            console.debug('Teams app.initialize failed in auth window.', teamsInitError);
          }
        }
        if (typeof teams?.initialize === 'function') {
          try {
            await new Promise((resolve) => {
              try {
                teams.initialize(
                  () => resolve(),
                  (reason) => {
                    console.debug('Teams initialize callback returned error in auth window.', reason);
                    resolve();
                  }
                );
              } catch (legacyInitError) {
                console.debug('Teams legacy initialize threw in auth window.', legacyInitError);
                resolve();
              }
            });
          } catch (legacyInitOuterError) {
            console.debug('Teams legacy initialize outer failure.', legacyInitOuterError);
          }
        }
        return teams;
      }

      async function notifyCompletion(payload) {
        const origin = window.location.origin;
        const initialisedTeams = await initialiseTeamsSdk();
        if (initialisedTeams?.authentication) {
          try {
            if (payload.success) {
              initialisedTeams.authentication.notifySuccess(JSON.stringify(payload));
            } else {
              initialisedTeams.authentication.notifyFailure(payload.error || 'Authentication failed.');
            }
          } catch (teamsNotifyError) {
            console.debug('Unable to notify Teams authentication result.', teamsNotifyError);
          }
        }
        const message = { type: 'bbprogramme-auth-complete', ...payload };
        try {
          if (window.opener && !window.opener.closed) {
            window.opener.postMessage(message, origin);
          }
        } catch (postError) {
          console.debug('Unable to post authentication completion message to opener.', postError);
        }
        try {
          if (window.parent && window.parent !== window) {
            window.parent.postMessage(message, origin);
          }
        } catch (parentPostError) {
          console.debug('Unable to post authentication completion message to parent frame.', parentPostError);
        }
      }

      if (!window.msal || !window.msal.PublicClientApplication) {
        console.error('MSAL browser library unavailable while finishing authentication.');
        await notifyCompletion({ success: false, error: 'MSAL library unavailable.' });
        window.close();
        return;
      }

      const app = new window.msal.PublicClientApplication({
        auth: { clientId: CLIENT_ID, authority, redirectUri },
        cache: { cacheLocation: 'sessionStorage', storeAuthStateInCookie: true }
      });

      try {
        if (typeof app.initialize === 'function') {
          await app.initialize();
        }

        let redirectResult = null;
        try {
          redirectResult = await app.handleRedirectPromise();
        } catch (handleRedirectError) {
          console.error('Authentication redirect handling failed.', handleRedirectError);
        }

        if (redirectResult?.account) {
          app.setActiveAccount(redirectResult.account);
        }

        let account = redirectResult?.account || null;
        if (!account) {
          const accounts = app.getAllAccounts();
          if (accounts.length) {
            account = accounts[0];
            app.setActiveAccount(account);
          }
        }

        if (!account) {
          if (!hasRedirectFlag(REDIRECT_SESSION_KEY)) {
            setRedirectFlag(REDIRECT_SESSION_KEY);
            try {
              await app.loginRedirect({
                scopes: GRAPH_SCOPES,
                prompt: 'select_account',
                redirectStartPage: window.location.href
              });
              return;
            } catch (loginError) {
              console.error('Authentication redirect invocation failed.', loginError);
              clearRedirectFlag(REDIRECT_SESSION_KEY);
              await notifyCompletion({
                success: false,
                error: loginError?.message || String(loginError || 'Unable to start authentication.')
              });
              return;
            }
          }
          clearRedirectFlag(REDIRECT_SESSION_KEY);
          await notifyCompletion({
            success: false,
            error: 'Authentication completed without selecting an account.'
          });
          return;
        }

        clearRedirectFlag(REDIRECT_SESSION_KEY);

        let tokenResult = redirectResult;
        if (!tokenResult?.accessToken) {
          try {
            tokenResult = await app.acquireTokenSilent({
              account,
              scopes: GRAPH_SCOPES
            });
          } catch (silentError) {
            const needsInteraction = (window.msal && window.msal.InteractionRequiredAuthError
              && silentError instanceof window.msal.InteractionRequiredAuthError)
              || silentError?.name === 'InteractionRequiredAuthError'
              || silentError?.errorCode === 'interaction_required'
              || silentError?.errorCode === 'consent_required'
              || silentError?.errorCode === 'no_tokens_found';
            if (needsInteraction) {
              if (!hasRedirectFlag(TOKEN_REDIRECT_KEY)) {
                setRedirectFlag(TOKEN_REDIRECT_KEY);
                await app.acquireTokenRedirect({
                  account,
                  scopes: GRAPH_SCOPES,
                  redirectStartPage: window.location.href
                });
                return;
              }
              clearRedirectFlag(TOKEN_REDIRECT_KEY);
              await notifyCompletion({
                success: false,
                error: 'Authentication cancelled before acquiring an access token.'
              });
              return;
            }
            clearRedirectFlag(TOKEN_REDIRECT_KEY);
            throw silentError;
          }
        }

        clearRedirectFlag(TOKEN_REDIRECT_KEY);

        if (!tokenResult?.accessToken) {
          await notifyCompletion({
            success: false,
            error: 'Authentication did not return an access token.'
          });
          return;
        }

        const payload = {
          success: true,
          accessToken: tokenResult.accessToken,
          expiresOn: tokenResult.expiresOn instanceof Date ? tokenResult.expiresOn.toISOString() : null,
          account: account
            ? {
                homeAccountId: account.homeAccountId,
                username: account.username,
                name: account.name || null
              }
            : null
        };

        await notifyCompletion(payload);
      } catch (error) {
        console.error('Authentication flow failed.', error);
        await notifyCompletion({
          success: false,
          error: error?.message || String(error || 'Unknown error')
        });
      } finally {
        setTimeout(() => {
          try {
            window.close();
          } catch (closeError) {
            console.debug('Unable to close authentication window automatically.', closeError);
          }
        }, 200);
      }
    }());
  </script>
</body>
</html>
